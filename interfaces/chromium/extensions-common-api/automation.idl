// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The <code>chrome.automation</code> API allows developers to access the
// automation (accessibility) tree for the browser. The tree resembles the DOM
// tree, but only exposes the <em>semantic</em> structure of a page. It can be
// used to programmatically interact with a page by examining names, roles, and
// states, listening for events, and performing actions on nodes.
[nocompile] namespace automation {
  // Keep the following enums in sync with 'ui/accessibility/ax_enums.mojom'.
  // They are kept here purely for extension docs generation.

  // Possible events fired on an $(ref:automation.AutomationNode).
  enum EventType {
    accessKeyChanged,
    activeDescendantChanged,
    alert,
    ariaAttributeChanged,
    ariaCurrentChanged,
    atomicChanged,
    autoCompleteChanged,
    autocorrectionOccured,
    autofillAvailabilityChanged,
    blur,
    busyChanged,
    caretBoundsChanged,
    checkedStateChanged,
    checkedStateDescriptionChanged,
    childrenChanged,
    classNameChanged,
    clicked,
    collapsed,
    controlsChanged,
    detailsChanged,
    describedByChanged,
    descriptionChanged,
    documentSelectionChanged,
    documentTitleChanged,
    dropeffectChanged,
    editableTextChanged,
    enabledChanged,
    endOfTest,
    expanded,
    expandedChanged,
    flowFromChanged,
    flowToChanged,
    focus,
    focusAfterMenuClose,
    focusChanged,
    focusContext,
    grabbedChanged,
    haspopupChanged,
    hide,
    hierarchicalLevelChanged,
    hitTestResult,
    hover,
    ignoredChanged,
    imageAnnotationChanged,
    imageFrameUpdated,
    invalidStatusChanged,
    keyShortcutsChanged,
    labeledByChanged,
    languageChanged,
    layoutComplete,
    layoutInvalidated,  // fired when aria-busy goes false
    liveRegionChanged,
    liveRegionCreated,
    liveRegionNodeChanged,  // fired on a node within a live region.
    liveRelevantChanged,
    liveStatusChanged,
    loadComplete,
    loadStart,
    locationChanged,
    mediaStartedPlaying,
    mediaStoppedPlaying,
    menuEnd,
    menuItemSelected,
    menuListValueChanged,
    menuPopupEnd,
    menuPopupStart,
    menuStart,
    mouseCanceled,
    mouseDragged,
    mouseMoved,
    mousePressed,
    mouseReleased,
    multilineStateChanged,
    multiselectableStateChanged,
    nameChanged,
    objectAttributeChanged,
    otherAttributeChanged,
    parentChanged,
    placeholderChanged,
    portalActivated,
    positionInSetChanged,
    rangeValueChanged,
    rangeValueMaxChanged,
    rangeValueMinChanged,
    rangeValueStepChanged,
    readonlyChanged,
    relatedNodeChanged,
    requiredStateChanged,
    roleChanged,
    rowCollapsed,
    rowCountChanged,
    rowExpanded,
    scrollHorizontalPositionChanged,
    scrollPositionChanged,
    scrollVerticalPositionChanged,
    scrolledToAnchor,
    selectedChanged,
    selectedChildrenChanged,
    selectedValueChanged,
    selection,
    selectionAdd,
    selectionRemove,
    setSizeChanged,
    show,
    sortChanged,
    stateChanged,
    subtreeCreated,
    textAttributeChanged,
    textSelectionChanged,
    textChanged,
    tooltipClosed,
    tooltipOpened,
    treeChanged,
    valueInTextFieldChanged,
    valueChanged,  // Deprecated.
    windowActivated,
    windowDeactivated,
    windowVisibilityChanged
  };

  // Describes the purpose of an $(ref:automation.AutomationNode).
  enum RoleType {
    abbr,
    alert,
    alertDialog,
    application,
    article,
    audio,
    banner,
    blockquote,
    button,
    canvas,
    caption,
    caret,
    cell,
    checkBox,
    client,
    code,
    colorWell,
    column,
    columnHeader,
    comboBoxGrouping,
    comboBoxMenuButton,
    comboBoxSelect,
    comment,
    complementary,
    contentDeletion,
    contentInsertion,
    contentInfo,
    date,
    dateTime,
    definition,
    descriptionList,
    descriptionListDetail,
    descriptionListTerm,
    desktop,
    details,
    dialog,
    directory,
    disclosureTriangle,
    // --------------------------------------------------------------
    // DPub Roles:
    // https://www.w3.org/TR/dpub-aam-1.0/#mapping_role_table
    docAbstract,
    docAcknowledgments,
    docAfterword,
    docAppendix,
    docBackLink,
    docBiblioEntry,
    docBibliography,
    docBiblioRef,
    docChapter,
    docColophon,
    docConclusion,
    docCover,
    docCredit,
    docCredits,
    docDedication,
    docEndnote,
    docEndnotes,
    docEpigraph,
    docEpilogue,
    docErrata,
    docExample,
    docFootnote,
    docForeword,
    docGlossary,
    docGlossRef,
    docIndex,
    docIntroduction,
    docNoteRef,
    docNotice,
    docPageBreak,
    docPageFooter,
    docPageHeader,
    docPageList,
    docPart,
    docPreface,
    docPrologue,
    docPullquote,
    docQna,
    docSubtitle,
    docTip,
    docToc,
    // End DPub roles.
    // --------------------------------------------------------------
    document,
    embeddedObject,
    emphasis,
    feed,
    figcaption,
    figure,
    footer,
    footerAsNonLandmark,
    form,
    genericContainer,
    // --------------------------------------------------------------
    // ARIA Graphics module roles:
    // https://rawgit.com/w3c/graphics-aam/master/#mapping_role_table
    graphicsDocument,
    graphicsObject,
    graphicsSymbol,
    // End ARIA Graphics module roles.
    // --------------------------------------------------------------
    grid,
    group,
    header,
    headerAsNonLandmark,
    heading,
    iframe,
    iframePresentational,
    image,
    imeCandidate,
    inlineTextBox,
    inputTime,
    keyboard,
    labelText,
    layoutTable,
    layoutTableCell,
    layoutTableRow,
    legend,
    lineBreak,
    link,
    list,
    listBox,
    listBoxOption,
    listGrid,  // Native
    listItem,
    listMarker,
    log,
    main,
    mark,
    marquee,
    math,
    mathMLFraction,
    mathMLIdentifier,
    mathMLMath,
    mathMLMultiscripts,
    mathMLNoneScript,
    mathMLNumber,
    mathMLOperator,
    mathMLOver,
    mathMLPrescriptDelimiter,
    mathMLRoot,
    mathMLRow,
    mathMLSquareRoot,
    mathMLStringLiteral,
    mathMLSub,
    mathMLSubSup,
    mathMLSup,
    mathMLTable,
    mathMLTableCell,
    mathMLTableRow,
    mathMLText,
    mathMLUnder,
    mathMLUnderOver,
    menu,
    menuBar,
    menuItem,
    menuItemCheckBox,
    menuItemRadio,
    menuListOption,
    menuListPopup,
    meter,
    navigation,
    note,
    pane,
    paragraph,
    pdfActionableHighlight,
    pdfRoot,
    pluginObject,
    popUpButton,
    portal,
    pre,
    progressIndicator,
    radioButton,
    radioGroup,
    region,
    rootWebArea,
    row,
    rowGroup,
    rowHeader,
    ruby,
    rubyAnnotation,
    scrollBar,
    scrollView,
    search,
    searchBox,
    section,
    slider,
    spinButton,
    splitter,
    staticText,
    status,
    strong,
    subscript,
    suggestion,
    superscript,
    svgRoot,
    switch,
    tab,
    tabList,
    tabPanel,
    table,
    tableHeaderContainer,
    term,
    textField,
    textFieldWithComboBox,
    time,
    timer,
    titleBar,
    toggleButton,
    toolbar,
    tooltip,
    tree,
    treeGrid,
    treeItem,
    unknown,
    video,
    webView,
    window
  };

  // Describes characteristics of an $(ref:automation.AutomationNode).
  enum StateType {
    autofillAvailable,
    collapsed,
    default,
    editable,
    expanded,
    focusable,
    focused,
    horizontal,
    hovered,
    ignored,
    invisible,
    linked,
    multiline,
    multiselectable,
    offscreen,
    protected,
    required,
    richlyEditable,
    vertical,
    visited
  };

  // All possible actions that can be performed on automation nodes.
  enum ActionType {
    annotatePageImages,
    blur,
    clearAccessibilityFocus,
    collapse,
    customAction,
    decrement,
    doDefault,
    expand,
    focus,
    getImageData,
    getTextLocation,
    hideTooltip,
    hitTest,
    increment,
    internalInvalidateTree,
    loadInlineTextBoxes,
    longClick,
    replaceSelectedText,
    resumeMedia,
    scrollBackward,
    scrollDown,
    scrollForward,
    scrollLeft,
    scrollRight,
    scrollUp,
    scrollToMakeVisible,
    scrollToPoint,
    scrollToPositionAtRowColumn,
    setAccessibilityFocus,
    setScrollOffset,
    setSelection,
    setSequentialFocusNavigationStartingPoint,
    setValue,
    showContextMenu,
    signalEndOfTest,
    showTooltip,
    startDuckingMedia,
    stopDuckingMedia,
    suspendMedia
  };

  // Possible changes to the automation tree. For any given atomic change
  // to the tree, each node that's added, removed, or changed, will appear
  // in exactly one TreeChange, with one of these types.
  //
  // nodeCreated means that this node was added to the tree and its parent is
  // new as well, so it's just one node in a new subtree that was added.
  enum TreeChangeType {
    /**
     * This node was added to the tree and its parent is new as well,
     * so it's just one node in a new subtree that was added.
     */
    nodeCreated,

    /**
     * This node was added to the tree but its parent was already in the
     * tree, so it's possibly the root of a new subtree - it does not mean
     * that it necessarily has children.
     */
    subtreeCreated,

    /**
     * This node changed.
     */
    nodeChanged,

    /**
     * This node's text (name) changed.
     */
    textChanged,

    /**
     * This node was removed.
     */
    nodeRemoved,
    /**
     * This subtree has finished an update.
     */
    subtreeUpdateEnd
  };

  // Where the node's name is from.
  enum NameFromType {
    attribute,
    attributeExplicitlyEmpty,
    caption,
    contents,
    placeholder,
    relatedElement,
    title,
    value
  };

  enum DescriptionFromType {
    ariaDescription,
    attributeExplicitlyEmpty,
    buttonLabel,
    popoverAttribute,
    relatedElement,
    rubyAnnotation,
    summary,
    svgDescElement,
    tableCaption,
    title
  };

  // The input restriction for a object -- even non-controls can be disabled.
  enum Restriction {
    disabled,
    readOnly
  };

  // Availability and types for an interactive popup element.
  enum HasPopup {
    false,
    true,
    menu,
    listbox,
    tree,
    grid,
    dialog
  };

  // Indicates the ARIA-current state.
  enum AriaCurrentState {
    false,
    true,
    page,
    step,
    location,
    date,
    time
  };

  // Lists the values that `invalidState` can take on.
  enum InvalidState {
    false,
    true
  };

  // Describes possible actions when performing a do default action.
  enum DefaultActionVerb {
    activate,
    check,
    click,
    clickAncestor,
    jump,
    open,
    press,
    select,
    uncheck
};

  // Types of markers on text. See <code>AutomationNode.markerTypes</code>.
enum MarkerType {
  spelling,
  grammar,
  textMatch,
  activeSuggestion,
  suggestion,
  highlight
};

// The following three enums are associated with an $(ref:automation.AutomationIntent).

// A command associated with an $(ref:automation.AutomationIntent).
enum IntentCommandType {
  clearSelection,
  delete,
  dictate,
  extendSelection,
  format,
  history,
  insert,
  marker,
  moveSelection,
  setSelection
};

// The type of an input event associated with an $(ref:automation.AutomationIntent). It describes an edit
// command, e.g. IntentCommandType.insert, in more detail.
enum IntentInputEventType {
  // Insertion.
  insertText,
  insertLineBreak,
  insertParagraph,
  insertOrderedList,
  insertUnorderedList,
  insertHorizontalRule,
  insertFromPaste,
  insertFromDrop,
  insertFromYank,
  insertTranspose,
  insertReplacementText,
  insertCompositionText,
  // Deletion.
  deleteWordBackward,
  deleteWordForward,
  deleteSoftLineBackward,
  deleteSoftLineForward,
  deleteHardLineBackward,
  deleteHardLineForward,
  deleteContentBackward,
  deleteContentForward,
  deleteByCut,
  deleteByDrag,
  // History.
  historyUndo,
  historyRedo,
  // Formatting.
  formatBold,
  formatItalic,
  formatUnderline,
  formatStrikeThrough,
  formatSuperscript,
  formatSubscript,
  formatJustifyCenter,
  formatJustifyFull,
  formatJustifyRight,
  formatJustifyLeft,
  formatIndent,
  formatOutdent,
  formatRemove,
  formatSetBlockTextDirection
};

// A text boundary associated with an $(ref:automation.AutomationIntent).
enum IntentTextBoundaryType {
  character,
  formatEnd,
  formatStart,
  formatStartOrEnd,
  lineEnd,
  lineStart,
  lineStartOrEnd,
  object,
  pageEnd,
  pageStart,
  pageStartOrEnd,
  paragraphEnd,
  paragraphStart,
  paragraphStartSkippingEmptyParagraphs,
  paragraphStartOrEnd,
  sentenceEnd,
  sentenceStart,
  sentenceStartOrEnd,
  webPage,
  wordEnd,
  wordStart,
  wordStartOrEnd
};

// A move direction associated with an $(ref:automation.AutomationIntent).
enum IntentMoveDirectionType {
  backward,
  forward
};

// A sort applied to a table row or column header.
enum SortDirectionType {
  unsorted,
  ascending,
  descending,
  other
};

// A type of AutomationPosition.
enum PositionType {
  null,
  text,
  tree
};

  dictionary Rect {
    long left;
    long top;
    long width;
    long height;
  };

  // Arguments for the find() and findAll() methods.
  [nocompile, noinline_doc] dictionary FindParams {
    RoleType? role;

    // A map of $(ref:automation.StateType) to boolean, indicating for each
    // state whether it should be set or not. For example:
    // <code>{ StateType.disabled: false }</code> would only match if
    // <code>StateType.disabled</code> was <em>not</em> present in the node's
    // <code>state</code> object.
    object? state;

    // A map of attribute name to expected value, for example
    // <code>{ name: 'Root directory', checkbox_mixed: true }</code>.
    // String attribute values may be specified as a regex, for example
    // <code>{ name: /stralia$/</code> }</code>.
    // Unless specifying a regex, the expected value must be an exact match
    // in type and value for the actual value. Thus, the type of expected value
    // must be one of:
    // <ul>
    // <li>string</li>
    // <li>integer</li>
    // <li>float</li>
    // <li>boolean</li>
    // </ul>
    object? attributes;
  };

  // Arguments for the setDocumentSelection() function.
  [nocompile, noinline_doc] dictionary SetDocumentSelectionParams {
    // The node where the selection begins.
    [instanceOf=AutomationNode] object anchorObject;

    // The offset in the anchor node where the selection begins.
    long anchorOffset;

    // The node where the selection ends.
    [instanceOf=AutomationNode] object focusObject;

    // The offset within the focus node where the selection ends.
    long focusOffset;
  };

  // Called when the result for a <code>query</code> is available.
  callback QueryCallback = void(AutomationNode node);

  [nocompile, noinline_doc] dictionary AutomationIntent {
    // A command associated with this AutomationIntent.
    IntentCommandType command;

    // A text boundary associated with this AutomationIntent.
    IntentTextBoundaryType textBoundary;

    // A move direction associated with this AutomationIntent.
    IntentMoveDirectionType moveDirection;
  };

  // An event in the Automation tree.
  [nocompile, noinline_doc] dictionary AutomationEvent {
    // The $(ref:automation.AutomationNode) to which the event was targeted.
    AutomationNode target;

    // The type of the event.
    EventType type;

    // The source of this event.
    DOMString eventFrom;

    // Any mouse coordinates associated with this event.
    long mouseX;
    long mouseY;

    // A list of $(ref:automation.AutomationIntent)s associated with this event.
    AutomationIntent[] intents;

    // Stops this event from further processing except for any remaining
    // listeners on $(ref:automation.AutomationEvent.target).
    static void stopPropagation();
  };

  // A listener for events on an <code>AutomationNode</code>.
  callback AutomationListener = void(AutomationEvent event);

  // A change to the Automation tree.
  [nocompile, noinline_doc] dictionary TreeChange {
    // The $(ref:automation.AutomationNode) that changed.
    AutomationNode target;

    // The type of change.
    TreeChangeType type;
  };

  // Possible tree changes to listen to using addTreeChangeObserver.
  // Note that listening to all tree changes can be expensive.
  enum TreeChangeObserverFilter {
    noTreeChanges,
    liveRegionTreeChanges,
    textMarkerChanges,
    allTreeChanges
  };

  // A listener for changes on the <code>AutomationNode</code> tree.
  callback TreeChangeObserver = void(TreeChange treeChange);

  // Callback called for actions with a response.
  callback PerformActionCallback = void(boolean result);
  callback PerformActionCallbackWithNode = void(AutomationNode node);
  callback BoundsForRangeCallback = void(Rect bounds);

      [nocompile, noinline_doc] dictionary CustomAction {
    long id;
    DOMString description;
  };

  // The string which the indices are relative to is not included in this
  // structure. See documentation on $(ref:languageAnnotationForStringAttribute)
  // for details on how to associate this object with a string.
  // Also, the start and end indices always point to the first code unit of a
  // valid code-point.
    [nocompile, noinline_doc] dictionary LanguageSpan {
    // Inclusive start index of substring that contains language.
    long startIndex;
    // Exclusive end index of substring that contains language.
    long endIndex;
    // Detected language for substring.
    DOMString language;
    // Probability that language is correct.
    double probability;
  };

    // A marker associated with an AutomationNode.
  [nocompile, noinline_doc] dictionary Marker {
    // The start offset within the text of the associated node.
    long startOffset;

    // The end offset within the text of the associated node.
    long endOffset;

    // A mapping of MarkerType to true or undefined indicating the marker types
    // for this marker.
    object flags;
  };

  // A position in the automation tree.
  // See ui/accessibility/ax_position.h for documentation. All members need to
  // be kept in sync with
  // extensions/renderer/api/automation/automation_position.h.
  // Some members there are kept private and not represented here.
  [nocompile, noinline_doc] dictionary AutomationPosition {

    AutomationNode? node;
    long childIndex;
    long textOffset;
    DOMString affinity;

    static boolean isNullPosition();
    static boolean isTreePosition();
    static boolean isTextPosition();
    static boolean isLeafTextPosition();
    static boolean atStartOfAnchor();
    static boolean atEndOfAnchor();
    static boolean atStartOfWord();
    static boolean atEndOfWord();
    static boolean atStartOfLine();
    static boolean atEndOfLine();
    static boolean atStartOfParagraph();
    static boolean atEndOfParagraph();
    static boolean atStartOfPage();
    static boolean atEndOfPage();
    static boolean atStartOfFormat();
    static boolean atEndOfFormat();
    static boolean atStartOfDocument();
    static boolean atEndOfDocument();
    static void asTreePosition();
    static void asTextPosition();
    static void asLeafTextPosition();
    static void moveToPositionAtStartOfAnchor();
    static void moveToPositionAtEndOfAnchor();
    static void moveToPositionAtStartOfDocument();
    static void moveToPositionAtEndOfDocument();
    static void moveToParentPosition();
    static void moveToNextLeafTreePosition();
    static void moveToPreviousLeafTreePosition();
    static void moveToNextLeafTextPosition();
    static void moveToPreviousLeafTextPosition();
    static void moveToNextCharacterPosition();
    static void moveToPreviousCharacterPosition();
    static void moveToNextWordStartPosition();
    static void moveToPreviousWordStartPosition();
    static void moveToNextWordEndPosition();
    static void moveToPreviousWordEndPosition();
    static void moveToNextLineStartPosition();
    static void moveToPreviousLineStartPosition();
    static void moveToNextLineEndPosition();
    static void moveToPreviousLineEndPosition();
    static void moveToNextFormatStartPosition();
    static void moveToPreviousFormatStartPosition();
    static void moveToNextFormatEndPosition();
    static void moveToPreviousFormatEndPosition();
    static void moveToNextParagraphStartPosition();
    static void moveToPreviousParagraphStartPosition();
    static void moveToNextParagraphEndPosition();
    static void moveToPreviousParagraphEndPosition();
    static void moveToNextPageStartPosition();
    static void moveToPreviousPageStartPosition();
    static void moveToNextPageEndPosition();
    static void moveToPreviousPageEndPosition();
    static void moveToNextAnchorPosition();
    static void moveToPreviousAnchorPosition();
    static long maxTextOffset();
    static boolean isInLineBreak();
    static boolean isInTextObject();
    static boolean isInWhiteSpace();
    static boolean isValid();
    static DOMString getText();
  };

  // A single node in an Automation tree.
  [nocompile, noinline_doc] dictionary AutomationNode {
    // The root node of the tree containing this AutomationNode.
    AutomationNode? root;

    // Whether this AutomationNode is a root node.
    boolean isRootNode;

    // The role of this node.
    RoleType? role;

    // The $(ref:automation.StateType)s describing this node.
    // <jsexterns>@type {Object<chrome.automation.StateType, boolean>}
    // </jsexterns>
    object? state;

    // The rendered location (as a bounding box) of this node in global
    // screen coordinates.
    Rect location;

    // Determines the location of the text within the node specified by
    // |startIndex| and |endIndex|, inclusively. Invokes |callback| with the
    // bounding rectangle, in screen coordinates. |callback| can be invoked
    // either synchronously or asynchronously. The bounds are clipped to
    // ancestors.
    static void boundsForRange(long startIndex, long endIndex,
        BoundsForRangeCallback callback);

    // Determines the location of the text within the node specified by
    // |startIndex| and |endIndex|, inclusively. Invokes |callback| with the
    // bounding rectangle, in screen coordinates. |callback| can be invoked
    // either synchronously or asynchronously. The bounds are not clipped to
    // ancestors.
    static void unclippedBoundsForRange(long startIndex, long endIndex,
        BoundsForRangeCallback callback);

    // The location (as a bounding box) of this node in global screen
    // coordinates without applying any clipping from ancestors.
    Rect? unclippedLocation;

    // The purpose of the node, other than the role, if any.
    DOMString? description;

    // Description of the state of the checkbox.
    // Used only when the node is checkable.
    DOMString? checkedStateDescription;

    // The placeholder for this text field, if any.
    DOMString? placeholder;

    // The role description for this node.
    DOMString? roleDescription;

    // The accessible name for this node, via the
    // <a href="http://www.w3.org/TR/wai-aria/#namecalculation">
    // Accessible Name Calculation</a> process.
    DOMString? name;

    // Explains what will happen when the doDefault action is performed.
    DOMString? doDefaultLabel;

    // Explains what will happen when the long click action is performed.
    DOMString? longClickLabel;

    // The tooltip of the node, if any.
    DOMString? tooltip;

    // The source of the name.
    NameFromType? nameFrom;

    // The image annotation for image nodes, which may be a human-readable
    // string that is the contextualized annotation or a status string related
    // to annotations.
    DOMString? imageAnnotation;

    // The value for this node: for example the <code>value</code> attribute of
    // an <code>&lt;input&gt; element.
    DOMString? value;

    // The HTML tag for this element, if this node is an HTML element.
    DOMString? htmlTag;

    // The level of a heading or tree item.
    long? hierarchicalLevel;

    // The current caret bounds in screen coordinates.
    Rect? caretBounds;

    // The start and end index of each word in an inline text box.
    long[]? wordStarts;
    long[]? wordEnds;

    // The start indexes of each sentence within the node's name.
    long[]? sentenceStarts;

    // The end indexes of each sentence within the node's name. For most nodes,
    // the size of sentenceStarts array should be equal to the size of
    // sentenceEnds array. Two exceptions are (1) node at the begining of a
    // paragraph but the end of the node's sentences is in its following node.
    // Such a node has one more start index. (2) Node at the end of a paragraph
    // but the start of the node's sentences is in its previous node. Such a
    // node has one more end index. For example, <p><b>Hello</b> world.</p> has
    // two nodes. The first one has one start index (i.e., 0) but no end index.
    // The second node has one end index (i.e., 7) but no start index.
    long[]? sentenceEnds;

    // The start index of each word within the node's name. This is different
    // from wordStarts because it is not restricted to inline text boxes and can
    // be used for any type of element.
    long[]? nonInlineTextWordStarts;

    // The end index of each word within the node's name. This is different
    // from wordEnds because it is not restricted to inline text boxes and can
    // be used for any type of element.
    long[]? nonInlineTextWordEnds;

    // The nodes, if any, which this node is specified to control via
    // <a href="http://www.w3.org/TR/wai-aria/#aria-controls">
    // <code>aria-controls</code></a>.
    AutomationNode[]? controls;

    // The nodes, if any, which form a description for this node.
    AutomationNode[]? describedBy;

    // The nodes, if any, which may optionally be navigated to after this
    // one. See
    // <a href="http://www.w3.org/TR/wai-aria/#aria-flowto">
    // <code>aria-flowto</code></a>.
    AutomationNode[]? flowTo;

    // The nodes, if any, which form a label for this element. Generally, the
    // text from these elements will also be exposed as the element's accessible
    // name, via the $(ref:automation.AutomationNode.name) attribute.
    AutomationNode[]? labelledBy;

    // The node referred to by <code>aria-activedescendant</code>, where
    // applicable
    AutomationNode? activeDescendant;

    // Reverse relationship for active descendant.
    AutomationNode[]? activeDescendantFor;

    // The target of an in-page link.
    AutomationNode? inPageLinkTarget;

    // A node that provides more details about the current node.
    AutomationNode[]? details;

    // A node that provides an error message for a current node.
    AutomationNode? errorMessage;

    // Reverse relationship for details.
    AutomationNode[]? detailsFor;

    // Reverse relationship for errorMessage.
    AutomationNode[]? errorMessageFor;

    // Reverse relationship for controls.
    AutomationNode[]? controlledBy;

    // Reverse relationship for describedBy.
    AutomationNode[]? descriptionFor;

    // Reverse relationship for flowTo.
    AutomationNode[]? flowFrom;

    // Reverse relationship for labelledBy.
    AutomationNode[]? labelFor;

    // The column header nodes for a table cell.
    AutomationNode[]? tableCellColumnHeaders;

    // The row header nodes for a table cell.
    AutomationNode[]? tableCellRowHeaders;

    // An array of standard actions available on this node.
    ActionType[]? standardActions;

    // An array of custom actions.
    CustomAction[]? customActions;

    // The action taken by calling <code>doDefault</code>.
    DefaultActionVerb? defaultActionVerb;

    //
    // Link attributes.
    //

    // The URL that this link will navigate to.
    DOMString? url;

    //
    // Document attributes.
    //

    // The URL of this document.
    DOMString? docUrl;

    // The title of this document.
    DOMString? docTitle;

    // Whether this document has finished loading.
    boolean? docLoaded;

    // The proportion (out of 1.0) that this doc has completed loading.
    double? docLoadingProgress;

    //
    // Scrollable container attributes.
    //

    long? scrollX;
    long? scrollXMin;
    long? scrollXMax;
    long? scrollY;
    long? scrollYMin;
    long? scrollYMax;

    // Indicates whether this node is scrollable.
    boolean? scrollable;

    //
    // Editable text field attributes.
    //

    // The character index of the start of the selection within this editable
    // text element; -1 if no selection.
    long? textSelStart;

    // The character index of the end of the selection within this editable
    // text element; -1 if no selection.
    long? textSelEnd;

    // An array of Marker objects for this node.
    Marker[]? markers;

    //
    // Tree selection attributes (available on root nodes only)
    //

    // If a selection is present, whether the anchor of the selection comes
    // after its focus in the accessibility tree.
    boolean? isSelectionBackward;
    // The anchor node of the tree selection, if any.
    AutomationNode? anchorObject;
    // The anchor offset of the tree selection, if any.
    long? anchorOffset;
    // The affinity of the tree selection anchor, if any.
    DOMString? anchorAffinity;
    // The focus node of the tree selection, if any.
    AutomationNode? focusObject;
    // The focus offset of the tree selection, if any.
    long? focusOffset;
    // The affinity of the tree selection focus, if any.
    DOMString? focusAffinity;

    // The selection start node of the tree selection, if any.
    AutomationNode? selectionStartObject;
    // The selection start offset of the tree selection, if any.
    long? selectionStartOffset;
    // The affinity of the tree selection start, if any.
    DOMString? selectionStartAffinity;
    // The selection end node of the tree selection, if any.
    AutomationNode? selectionEndObject;
    // The selection end offset of the tree selection, if any.
    long? selectionEndOffset;
    // The affinity of the tree selection end, if any.
    DOMString? selectionEndAffinity;

    // Indicates that the node is marked user-select:none
    boolean? notUserSelectableStyle;

    //
    // Range attributes.
    //

    // The current value for this range.
    double? valueForRange;

    // The minimum possible value for this range.
    double? minValueForRange;

    // The maximum possible value for this range.
    double? maxValueForRange;

    //
    // List attributes.
    //

    // The 1-based index of an item in a set.
    long? posInSet;

    // The number of items in a set;
    long? setSize;

    //
    // Table attributes.
    //

    // The number of rows in this table as specified in the DOM.
    long? tableRowCount;

    // The number of rows in this table as specified by the page author.
    long? ariaRowCount;

    // The number of columns in this table as specified in the DOM.
    long? tableColumnCount;

    // The number of columns in this table as specified by the page author.
    long? ariaColumnCount;

    //
    // Table cell attributes.
    //

    // The zero-based index of the column that this cell is in as specified in
    // the DOM.
    long? tableCellColumnIndex;

    // The ARIA column index as specified by the page author.
    long? tableCellAriaColumnIndex;

    // The number of columns that this cell spans (default is 1).
    long? tableCellColumnSpan;

    // The zero-based index of the row that this cell is in as specified in the
    // DOM.
    long? tableCellRowIndex;

    // The ARIA row index as specified by the page author.
    long? tableCellAriaRowIndex;

    // The number of rows that this cell spans (default is 1).
    long? tableCellRowSpan;

    // The corresponding column header for this cell.
    AutomationNode? tableColumnHeader;

    // The corresponding row header for this cell.
    AutomationNode? tableRowHeader;

    // The column index of this column node.
    long? tableColumnIndex;

    // The row index of this row node.
    long? tableRowIndex;

    //
    // Live region attributes.
    //

    // The type of region if this is the root of a live region.
    // Possible values are 'polite' and 'assertive'.
    DOMString? liveStatus;

    // The value of aria-relevant for a live region.
    DOMString? liveRelevant;

    // The value of aria-atomic for a live region.
    boolean? liveAtomic;

    // The value of aria-busy for a live region or any other element.
    boolean? busy;

    // The type of live region if this node is inside a live region.
    DOMString? containerLiveStatus;

    // The value of aria-relevant if this node is inside a live region.
    DOMString? containerLiveRelevant;

    // The value of aria-atomic if this node is inside a live region.
    boolean? containerLiveAtomic;

    // The value of aria-busy if this node is inside a live region.
    boolean? containerLiveBusy;

    //
    // Miscellaneous attributes.
    //

    // Whether or not this node is a button.
    boolean isButton;

  // Whether or not this node is a checkbox.
    boolean isCheckBox;

    // Whether or not this node is a combobox.
    boolean isComboBox;

    // Whether or not this node is an image.
    boolean isImage;

    // Aria auto complete.
    DOMString? autoComplete;

    // The name of the programmatic backing object.
    DOMString? className;

    // Marks this subtree as modal.
    boolean? modal;

    // A map containing all HTML attributes and their values
    // <jsexterns>@type {Object<string>}</jsexterns>
    object? htmlAttributes;

    // The input type of a text field, such as "text" or "email".
    DOMString? inputType;

    // The key that activates this widget.
    DOMString? accessKey;

    // The value of the aria-invalid attribute, indicating the error type.
    DOMString? ariaInvalidValue;

    // The CSS display attribute for this node, if applicable.
    DOMString? display;

    // A data url with the contents of this object's image or thumbnail.
    DOMString? imageDataUrl;

    // The author-provided language code for this subtree.
    DOMString? language;

    // The detected language code for this subtree.
    DOMString? detectedLanguage;

    // Indicates the availability and type of an interactive popup element.
    HasPopup? hasPopup;

    // Input restriction, if any, such as readonly or disabled:
    // undefined - enabled control or other object that is not disabled
    // Restriction.DISABLED - disallows input in itself + any descendants
    // Restriction.READONLY - allow focus/selection but not input
    DOMString? restriction;

    // Tri-state describing checkbox or radio button:
    // 'false' | 'true' | 'mixed'
    DOMString? checked;

    // The inner html of this element. Only populated for math content.
    DOMString? innerHtml;

    // The RGBA foreground color of this subtree, as an integer.
    long? color;

    // The RGBA background color of this subtree, as an integer.
    long? backgroundColor;

    // The RGBA color of an input element whose value is a color.
    long? colorValue;

    // Indicates node text is subscript.
    boolean subscript;

    // Indicates node text is superscript.
    boolean superscript;

    // Indicates node text is bold.
    boolean bold;

    // Indicates node text is italic.
    boolean italic;

    // Indicates node text is underline.
    boolean underline;

    // Indicates node text is line through.
    boolean lineThrough;

    // Indicates whether this node is selected, unselected, or neither.
    boolean? selected;

    // Indicates the font size of this node.
    long? fontSize;

    // Indicates the font family.
    DOMString fontFamily;

    // Indicates whether the object functions as a text field which exposes its
    // descendants. Use cases include the root of a content-editable region, an
    // ARIA textbox which isn't currently editable and which has interactive
    // descendants, and a <body> element that has "design-mode" set to "on".
    boolean nonAtomicTextFieldRoot;

    // Indicates aria-current state.
    AriaCurrentState? ariaCurrentState;

    // Indicates invalid-state.
    InvalidState? invalidState;

    // The application id for a tree rooted at this node.
    DOMString? appId;

    //
    // Walking the tree.
    //

    AutomationNode[] children;
    AutomationNode? parent;
    AutomationNode? firstChild;
    AutomationNode? lastChild;
    AutomationNode? previousSibling;
    AutomationNode? nextSibling;
    AutomationNode? previousOnLine;
    AutomationNode? nextOnLine;
    AutomationNode? previousFocus;
    AutomationNode? nextFocus;
    AutomationNode? previousWindowFocus;
    AutomationNode? nextWindowFocus;

    // The index of this node in its parent node's list of children. If this is
    // the root node, this will be undefined.
    long? indexInParent;

    // The sort direction of this node.
    SortDirectionType sortDirection;

    // Explicitly set to true when this node is clickable.
    boolean clickable;

    //
    // Actions.
    //

    // Does the default action based on this node's role. This is generally
    // the same action that would result from clicking the node such as
    // expanding a treeitem, toggling a checkbox, selecting a radiobutton,
    // or activating a button.
    static void doDefault();

    // Places focus on this node.
    static void focus();

    // Request a data url for the contents of an image, optionally
    // resized.  Pass zero for maxWidth and/or maxHeight for the
    // original size.
    static void getImageData(long maxWidth, long maxHeight);

    // Does a hit test of the given global screen coordinates, and fires
    // eventToFire on the resulting object.
    static void hitTest(
        long x,
        long y,
        EventType eventToFire);

    // Does a $(ref:automation.AutomationNode.hitTest), and receives a callback
    // with the resulting hit node.
    static void hitTestWithReply(
        long x,
        long y,
        PerformActionCallbackWithNode callback);

    // Scrolls this node to make it visible.
    static void makeVisible();

    // Performs custom action.
    static void performCustomAction(long customActionId);

    // Convenience method to perform a standard action supported by this node.
    // For actions requiring additional arguments, call the specific binding
    // e.g. <code>setSelection</code>.
    static void performStandardAction(ActionType actionType);

    // Replaces the selected text within a text field.
    static void replaceSelectedText(DOMString value);

    // Sets accessibility focus. Accessibility focus is the node on which an
    // extension tracks a user's focus. This may be conveyed through a focus
    // ring or or speech output by the extension. Automation will dispatch more
    // events to the accessibility focus such as location changes.
    static void setAccessibilityFocus();

    // Sets selection within a text field.
    static void setSelection(long startIndex, long endIndex);

    // Clears focus and sets this node as the starting point for the next
    // time the user presses Tab or Shift+Tab.
    static void setSequentialFocusNavigationStartingPoint();

    // Sets the value of a text field.
    static void setValue(DOMString value);

    // Show the context menu for this element, as if the user right-clicked.
    static void showContextMenu();

    // Resume playing any media within this tree.
    static void resumeMedia();

    // Start ducking any media within this tree.
    static void startDuckingMedia();

    // Stop ducking any media within this tree.
    static void stopDuckingMedia();

    // Suspend any media playing within this tree.
    static void suspendMedia();

    // Simulates long click on node.
    static void longClick();

    // Scrolls this scrollable container backward.
    static void scrollBackward(optional PerformActionCallback callback);

    // Scrolls this scrollable container forward.
    static void scrollForward(optional PerformActionCallback callback);

    // Scrolls this scrollable container up.
    static void scrollUp(optional PerformActionCallback callback);

    // Scrolls this scrollable container down.
    static void scrollDown(optional PerformActionCallback callback);

    // Scrolls this scrollable container left.
    static void scrollLeft(optional PerformActionCallback callback);

    // Scrolls this scrollable container right.
    static void scrollRight(optional PerformActionCallback callback);

    // Scrolls this scrollable container to the given point.
    static void scrollToPoint(long x, long y);

    // Sets this scrollable container's scroll offset.
    static void setScrollOffset(long x, long y);

    // Adds a listener for the given event type and event phase.
    static void addEventListener(
        EventType eventType, AutomationListener listener, boolean capture);

    // Removes a listener for the given event type and event phase.
    static void removeEventListener(
        EventType eventType, AutomationListener listener, boolean capture);

    // Gets the first node in this node's subtree which matches the given CSS
    // selector and is within the same DOM context.
    //
    // If this node doesn't correspond directly with an HTML node in the DOM,
    // querySelector will be run on this node's nearest HTML node ancestor. Note
    // that this may result in the query returning a node which is not a
    // descendant of this node.
    //
    // If the selector matches a node which doesn't directly correspond to an
    // automation node (for example an element within an ARIA widget, where the
    // ARIA widget forms one node of the automation tree, or an element which
    // is hidden from accessibility via hiding it using CSS or using
    // aria-hidden), this will return the nearest ancestor which does correspond
    // to an automation node.
    static void domQuerySelector(DOMString selector, QueryCallback callback);

    // Finds the first AutomationNode in this node's subtree which matches the
    // given search parameters.
    static AutomationNode find(FindParams params);

    // Finds all the AutomationNodes in this node's subtree which matches the
    // given search parameters.
    static AutomationNode[] findAll(FindParams params);

    // Returns whether this node matches the given $(ref:automation.FindParams).
    static boolean matches(FindParams params);

    static AutomationNode getNextTextMatch(
        DOMString searchStr, boolean backward);

    // Returns the detected languages for the provided string attribute as an
    // array of LanguageSpan objects. There are several guarantees about the
    // format of the LanguageSpan array:
    // 1. Is either empty or contains LanguageSpans that cover all indices in
    // the associated string attribute value.
    // 2. Is sorted by increasing startIndex (those with smaller startIndex
    // appear first).
    // 3. LanguageSpans are non-overlapping and contain exactly one language.
    static LanguageSpan[] languageAnnotationForStringAttribute(
        DOMString attribute);

    // Creates a position object backed by Chrome's accessibility position support.
    static AutomationPosition createPosition(PositionType type, long offset, optional boolean isUpstream);
  };

  // Called when the <code>AutomationNode</code> for the page is available.
  callback RootCallback = void(AutomationNode rootNode);

  // Called with the <code>AutomationNode</code> that currently has focus.
  callback FocusCallback = void(AutomationNode focusedNode);

  // Called with the <code>AutomationNode</code> that currently has
  // accessibility focus.
  callback AccessibilityFocusCallback = void(AutomationNode focusedNode);

  interface Functions {
    // Get the automation tree for the tab with the given tabId, or the current
    // tab if no tabID is given, enabling automation if necessary. Returns a
    // tree with a placeholder root node; listen for the "loadComplete" event to
    // get a notification that the tree has fully loaded (the previous root node
    // reference will stop working at or before this point).
    [nocompile] static void getTree(optional long tabId,
                                    optional RootCallback callback);

    // Get the automation tree for the whole desktop which consists of all on
    // screen views. Note this API is currently only supported on Chrome OS.
    [nocompile] static void getDesktop(RootCallback callback);

    // Get the automation node that currently has focus, globally. Will return
    // null if none of the nodes in any loaded trees have focus.
    [nocompile] static void getFocus(FocusCallback callback);

    // Get the automation node that currently has accessibility focus, globally.
    // Will return null if none of the nodes in any loaded trees have
    // accessibility focus.
    [nocompile] static void getAccessibilityFocus(
        AccessibilityFocusCallback callback);

    // Add a tree change observer. Tree change observers are static/global, they
    // listen to changes across all trees. Pass a filter to determine what
    // specific tree changes to listen to, and note that listnening to all
    // tree changes can be expensive.
    [nocompile] static void addTreeChangeObserver(
        TreeChangeObserverFilter filter, TreeChangeObserver observer);

    // Remove a tree change observer.
    [nocompile] static void removeTreeChangeObserver(
        TreeChangeObserver observer);

    // Sets the selection in a tree. This creates a selection in a single
    // tree (anchorObject and focusObject must have the same root).
    // Everything in the tree between the two node/offset pairs gets included
    // in the selection. The anchor is where the user started the selection,
    // while the focus is the point at which the selection gets extended
    // e.g. when dragging with a mouse or using the keyboard. For nodes with
    // the role staticText, the offset gives the character offset within
    // the value where the selection starts or ends, respectively.
    [nocompile] static void setDocumentSelection(
        SetDocumentSelectionParams params);
  };
};

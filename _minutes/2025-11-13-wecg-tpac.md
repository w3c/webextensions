# WECG TPAC Nov 13, 2025


## Agenda

https://github.com/w3c/webextensions/wiki/TPAC-2025-Coordination#thursday

(all times JST, UTC+9)

 * Secure Storage – 09:00 to 09:30
 * Clickjacking protections – 9:30 to 10:30
 * User Gestures – 11:00 to 11:45
 * Bug Triage – 11:45 to 12:30
 * Session 5 – 13:45 to 14:15
 * Sidebar API – 14:15 to 15:00


## Attendees

 * Rob Wu (Mozilla)
 * Simeon Vincent (Mozilla)
 * Kiara Rose (Apple)
 * Carlos Jeurissen (Independent)
 * Pattrick Kettner (Google Chrome)
 * Oliver Dunk (Google Chrome)
 * Devlin Cronin (Google Chrome)
 * Jordan Spivak (Capital One)
 * Casey Garland (Capital One)
 * George Henderson (Capital One)
 * Ricky Mondello (Apple)
 * Timothy Hatcher (Apple)
 * Rene Levelle (1Password)
 * Christian Brand (1Password)
 * Mukul Purohit (Microsoft)


## Notes


### Secure Storage

9:00 - 9:30

 * [rene] At 1Password we deal with a lot of secrets. Only way to work with this data currently is to store data behind a long password in a locked state. Ideally we'd use some form of biometry to get UV-backed storage access to encrypt and store this data in a browser extension context securely. Interested in reviving the secure storage proposal
   * https://github.com/w3c/webextensions/blob/main/proposals/secure-storage.md
 * [simeon] Can you clarify UV and UV-less storage?
 * [rene] UV, user verification: Touch ID, PIN entry on Windows, Windows Hello, etc.
 * [christian] We'd like an API to get a credential, store a credential, set a credential without UV access again. One with getting a system-level UI to request again, not just for unlocking a password manager, but also storing/protecting secrets before the user has unlocked the device again. Protecting email addresses ahead of time.
 * [rene] To get it out ahead of time: we have thought of WebAuthn, but it is not an ideal flow. (...) manually selecting passkeys, ...
 * [ricky] WebAuthN as it exists today, is focused on sign in, not unlocking use cases. User-facing impedance mismatch there. I want to talk through the problem from a different angle: Apple ships a password manager for non-Safari browsers. It gets its data from the native messaging application for functionality, which is based on pipes, which aren't securable to a level of satisfaction. Our extension makes the user pin-pair the extension. We'd love to be able to store a symmetric key-pair to save a secret, but we can't. Malware on the user's system can dig around and find that secret. Secure storage is necessary to secure this connection. If it was keychain backed and only the browser that wrote it can read it back. Would love to find out (and verify) that browsers store extension data securely.
 * [christian] Based on our research, browsers don't store data that way.
 * [christian] Open Chromium bug about how browsers talk with nativeMessaging hosts, but no progress. We believe secure storage to be generally useful.
 * [rene] If nativeMessaging on platforms like macOS support upgrading from stdio to XPC with authenticated endpoints would remove our need for this capability, but it could still be useful for others.
 * [christain] Any questions?
 * [rob] Even if we had native messaging APIs exactly as described, external applications can put a native messaging host json in a user location to fake the connection. How the browser knows where to find the native messaging host is through the native manifest. System and user locations. Based on that, the browser knows what application to communicate with. What do you think of that?
 * [ricky] Two potential problems. One is that the wrong extension/web context talks to the legitimate native messaging application. There, the legitimate native messaging host lists the extension's origin - the extension ID. We're talking about the opposite: someone installed the legitimate extension and the native application is faked. That application wouldn't have the user's passwords, but the application could collect a master password and potentially do something with it. That's of concern, but different than what we were talking about.
 * [christian] May be different from the use case just described, but someone could install another application that decompiles our app, steals our UI, fakes our application. That category of attack is very hard to guard against. If malicious code is able to run on the user's device, they have so many ways to take advantage of the system.
 * [rob] So in this case you're not concerned about local compromises?
 * [christian] We're interested in protecting against a non-interactive attacker. This is closer to passive, but somewhere between passive and active. They want to steal secrets without the user's knowledge. They want to info-steal. Upload databases to a mothership. The user is being phished, essentially. If we store data without the secure storage proposal, the malware could silently exfiltrate.
 * [ricky] Could be fair to say that the threat you brought up is legitimate and important, but not currently our lowest hanging fruit. This is a story about a lack of a sound security primitive, meaning the user experience to protect the user is compromised. If every app on desktop operating systems wrote data to a place nothing else could access, we wouldn't be having this conversation because data would already be sandboxed.
 * [rob] Is in-memory storage not enough for your use case?
 * [ricky] In both of our use cases, we want to be able to store data across browser relaunches.
 * [christian] 1Password's use case is running an extension in a standalone context without a native application to coordinate with, but we're also interested in securely storing data to establish long term identity with something else on the other side of these pipes.
 * [ricky] In our conversations, we've identified that this primitive would address both use cases and possibly others.
 * [christian] We've also spoken with a few other password managers that are interested in this solution.
 * [rene] Bitwarden, Devolutions, Dashlane would all jump on this if it were available.
 * [timothy] I can imagine Metamask and Web3 extensions would as well.
 * [ricky] Crypto wallets right? They sound like they would benefit from this.
 * [rob] There was already a proposal from Oliver on this, already linked near the top of this section.
 * [oliver] When working on the proposal, we went back and forth on the granularity that should be supported for specifying allowed authentication mechanisms. The current proposal lets you set a list of methods that callers would be comfortable using like pin unlock, biometric, etc. and mapping that to what is available on the system.
 * [christian] Risks associated with exposing methods of securing the storage (wrong phrasing, not sure what to use?) not worth the additional work. (...) fingerprinting.
 * [rob] For extensions, not too concerned about this fingerprinting risk.
 * [ricky] We've worked hard in webauthn to extract specific authentication mechanisms, to some people's chagrin. Could have a reputational risk to do it in a different part of the web platform.
 * [rene] When we first started discussing this we were looking for a solution that could also be used on the web platform, so fingerprint risk was more relevant.
 * [rob] We should define what risk is and is not in scope. Will help facilitate design and communication with other stakeholders.
 * [ricky] You want a clear enumeration of, not threat, but the expectation of the benefit.
 * [rob] And the gaps, so they are known and accepted. It's currently not clear that others understand and accept the limits.
 * [oliver] The proposal in its current form allows specifying string data, currently &lt; 1kb. Christian, I believe you sounded open to either this or just being able to store a single key.
 * [ricky] You can write a small amount of data that can be used to decrypt a larger amount of data stored elsewhere. Having limits that allow for security and timing guarantees seems useful.
 * [christian] Seems useful for storing small, sensitive pieces of info.
 * [rob] Would there even be a point in storing strings, or should we store typed arrays?
 * [christian] One benefit is that some backends make it much easier to debug strings than an opaque byte array. Not make or break, but strings tend to be more debuggable.
 * [ricky] Sounds like a nice to have.
 * [rob] Any concrete next steps?
 * [christian] You had asked for a list of places where the security model could fail or fall over, and to write out why they are okay.
 * [rob] Main value of this exercise is to confirm that what we're pursuing is useful.
 * [christian] The other thing, if there's no objection, is to make a PR for a simplified proposal over what's in the current draft spec created a few years ago to have a simpler API that is closer to WebAuthN.
 * [rob] Oliver, any preference on whether we update or replace the existing proposal doc?
 * [oliver] Updating the existing doc is fine.
 * [oliver] On the Firefox side, is this something you'd be interested in? On the Chrome side we haven't been sure if we can prioritize this.
 * [rob] Patches are welcome. If we're all agreed that we should do it, I don't have any hesitation about providing reviews.
 * [oliver] One of the concerns we've had in the past is the maintenance burden of having this work across platforms. Sounds like there may still be value in having this work in as many platforms as we can.
 * [christian] Being able to use this where we can is a net win.
 * [ricky] Perfect, enemy of good, etc.
 * [rene] With time this will become a more ubiquitous feature, even if we can't have it everywhere right now. As for maintenance, AFAIK device-bound session cookies (DBSC) architecture does have some consistent backing across platforms. Not exactly the same threat model as what we have, but perhaps tying into that architecture could help with long term maintenance. Device Bound Session Cookies is being developed in the WebApp Sec WG. Defines a cookie that is bound to a device. Used for fighting remote exfiltration as it wouldn't be useful on any other device. May or may not be stored in a hardware enclave. Perhaps if we hook into this the maintenance burden might be lower.
 * [ricky] I believe I heard that DBSC is supported on Windows. I don't expect Mac to be the hard part.
 * [rob] DBSC is Chrome-only; Has not been implemented in Firefox at the moment. Input from Apple?
 * [kiara] Can't speak to prioritization or implementation timeline. If there was a proposal, would we be interested in sponsoring this, Tim?
 * [timothy] Yes.
 * [rob] API doc currently defines firm APIs for get, set, etc. During discussion there was also the possibility of it not being available, should we expand error handling?
 * [christian] Not being supported sounds useful. Should be a way to report that the secret has become unavailable either temporarily or permanently.
 * [rob] I was thinking about guarantees. I assume an API user would want guarantees about confidentiality rather than unavailability.
 * [christian] In my personal experience these are not reliable APIs on any platform. Would be good to mention this in an explainer.
 * [rob] As Oliver mentioned, maintainability is a concern on the browser side. One way to reduce the maintenance burden is to allow for lower guarantees of availability.
 * [ricky] I'm hearing you talk about data integrity and durability. It's framed as secure storage, not secure cache.
 * [christian] Local storage is not perfectly durable today. Something could fiddle with bits, a FS could become corrupted, you could wipe TPM state and lose your bitlocker key, etc. These are problems people are used to dealing with outside the browser. We should be upfront about what we can and cannot promise.
 * [rob] In this conversation it's clear there are high expectations of durability. That could translate to higher maintenance costs. If we rely on an OS-provided system API or library and that becomes unavailable, we would have to look for alternatives.
 * [oliver] To be clear for the notes, we agree there are some situations where having high durability would be useful, for everyone in the room, durability is less important.
 * [ricky] Yes. Thanks for clarifying that.
 * **Action Item**: Update [secure-storage.md](https://github.com/w3c/webextensions/blob/658db413f3ed81f319cad576ab7f07a03712ee05/proposals/secure-storage.md) based on feedback.


### Click-jacking protections

9:45 - 10:45
Discuss reliably drawing on top of a page ([issue 235](https://github.com/w3c/webextensions/issues/235)). Allows extension to draw over a page without interference/clickjacking by the page.

 * [christian] 1Password prepared a doc.
 * [Clickjacking and Extensions](https://docs.google.com/presentation/d/1PxQSCcX91hdhY5Yag5QToWnAHGtnQxhrUaa6WDN_cXo/edit?usp=sharing)
   * [rob] (post meeting) Converted external link to markdown document for archival purposes: [2025-11-13-wecg-tpac-clickjacking.md](https://github.com/w3c/webextensions/blob/main/_minutes/2025-11-13-wecg-tpac-clickjacking.md).
 * [christian] The problem we'd like to discuss today is what the industry commonly calls clickjacking. The extension drawing UI inside the untrusted DOM. Interactions between other content in the page and potential mysterious interactions.
 * [christian] Generally password managers work by annotating fields in web content to flag fields that take a user name, password, etc. These are generally sensitive actions. You are taking content that has been stored and end-to-end encrypted, hasn't been exposed to a page, and you're now revealing a specific piece of data to a website. To make sure it's said, extensions lack privileged control of the visual layer. Extensions are only able to draw inside the same DOM and rendering layer as the page itself. Anything above that is reserved for the browser itself, such as confirmation dialogs, permissions, or in some cases the browser's own password UI. Concerns are being able to change the destination of a click event in order to transfer information from a secure to an insecure context without the user knowing.
 * [christian] Several extensions have tried to address this in a number of ways including shadow realms, mutation observers, etc. The list is very long. It's a game of cat and mouse of threat and risk. Looking for reactive events or looking for time of use. There's no guaranteed way to get this data in a trusted fashion.
 * [rene] Whenever the user interacts with the page, there's no way of them telling whether the interaction is with the page itself or the content of the extension.
 * [rene] When an extension injects itself, extensions can try a number of methods to stay on top of other content: &lt;dialog> showModal, z-index fights, etc. These approaches aren't well catered to the type of UX we're trying to achieve here.
 * [rene] By design, pages can still display things above our UI. They can also just make a transparent element that's interactable above our UI.
 * [rene] Overlay detection is hard and fragile. Game of cat and mouse. We can do intersection observability, but there are a lot of false positives and it's expensive to run, slows down the UI. Mutation observes to detect content changes, but shadow roots counter. Monkeypatching, and the page monkey patches the patches.
 * [rene] Can't detect if we're blocking a malicious use of this API or if we're blocking a legitimate use. Can end up breaking websites.
 * [christian] One thing we didn't have time to include is that there's been BSides presentations, online blogs, various other places where researchers claim to have solutions. There are reasons we can't adopt some of those solutions. The extension's execution is governed by the page's CSP. Not possible to use an alert in all cases. Can't anticipate what all pages will do in the wild.
 * [christian] Before continuing to solutions, any thoughts?
 * [oliver] Thanks for the presentation. That was quite useful.
 * [ricky] Having spent time trying to counter this, I'm convinced that the extension sharing in the same visual area of the page fundamentally cannot ensure integrity etc.
 * [rob] Agreed. But I wanted to see the proposed solutions before commenting that.
 * [ricky] One could imagine a world where an extension could call up and display a page that has a transparent background.
 * [christian] Three approaches are living rent free in my head: 1) Virtual website overlay. 2) A more complicated version of that, there's a separate new rendering layer reserved for extensions. For example, the extension popup is on top of the page. That could get expanded. 3) An expansion of the openPopup() API that we have today (without user interaction). There could be limitations there to accommodate mobile use cases.
 * [devlin] Doesn't necessarily help with user understanding of that layer. Gives extension developers confidence, but doesn't help the user understand the situation. In Chrome, we have this concept of the line of death, because no web page can draw above this. There's no way for a user to differentiate between those layers. These ideas don't have that type of guarantee. Is that a concern?
 * [rene] Yes. Invisible transparent layer above our UI is a known concern today.
 * [devlin] Even if the extension does not show anything, a web page can spoof the UI to trick the user into believing it to be interacting with the extension.
 * [christian] That concern has come up in the past with clickjacking and user safety. We made it impossible for users to enter their account passwords in the sketchy area because we didn't want users to get used to entering their credentials in UI that could be faked. So users are forced to interact with the popup. This forces the user to refocus from where they were interacting to a popup, but that's a tradeoff we've decided to make. But that concern is orthogonal to the other UI that we expose in the browser.
 * [devlin] For clarity, what's the main concern with clickjacking?
 * [christian] General PII; Credit card and address info, which is not bound to a specific origin, unlike passwords.
 * [devlin] Inverse clickjacking? Usually you trick the user into clicking on your UI, but in this case it's tricking on the web page's UI.
 * [rene] Credit card information; we'd like to show a confirmation prompt drawn by the browser. We've expanded this to other types. But expanding from clicking in the field and showing a modal is not the best experience.
 * [devlin] When discussing this internally in the past, the simpler solution has been to determine whether or not you're actually on top. That seems like that would address the same set of concerns.
 * [rob] That doesn't solve it. That doesn't address what was happening a few milliseconds before. Also CSS transform tricks, etc.
 * [ricky] My gut also says this may not be sufficient. Timing attack, or other such may.
 * [devlin] Would that concern also exist with a separate rendering layer?
 * [ricky] If the page has no idea I'm going to do something because it doesn't have any insight into what I'm doing to prepare or display my UI… I don't know.
 * [oliver] There are also cases that we haven't discussed. Not security guarantees, but just wanting to draw on top of other content. Use cases like accessibility. We already have the concept of a top player. Order is entirely based on when content was promoted to the top layer, ordering is handled by the browser.
 * [george] Expect that would also create issues with extensions competing over the top layer.
 * [oliver] How concerned are we with extensions competing here? Is just being on top of page content a useful improvement?
 * [ricky] Yes.
 * [george] Guaranteeing being on the top, the last element in the page after the `<body>`.
 * [rob] Does that require mixing the dom from the content script and the web page? Any solution that mixes DOM of the page and the content is going to be difficult. A CSS transformation on the document element could also mess with rendering.
 * [ricky] I'm imaging the top layer as the stratosphere, and the extension layer as the top of the stratosphere. Is that accurate?
 * [oliver] Yes.
 * [rob] Where does `window.prompt()` live? The web page could use that to take input?
 * [christina] No typed text. We're not interested in changing how the user unlocks their extension context. Even if we have a secure layer, we don't want users to get used to entering their credentials in unsecure contexts. We're only interested in painting and click events.
 * [rob] On desktop you have openPopup(), on Firefox for Android, that completely replaces the tab. Is that a problem?
 * [christian] 1Password specific, we only have an extension on iOS. In that case we have native code execution, so we have other ways of entering credentials other than typing a password.
 * [carlos] To comment on this, on iOS the popup is an overlay.
 * [ricky] `window.prompt()` was a fun one to think about.
 * [oliver] If there's interest in the top layer approach, might be other interesting things to think about.
 * [devlin] Isn't the potential of timing attacks still a concern? Seems like the same problem space still exists.
 * [oliver] We're saying anything in the top layer from an extension draws on top of everything else.
 * [devlin] But you'd still potentially be subject to timing attack if the page has an idea of when they'll interact. Say there's a password field on the field. If the extension is listening on mouseup, the page registered a listener on mousedown and shows an “accept privacy policy”
 * [ricky] To expand on that example, the page listens on mouse down, the extension listens on mouse up.
 * [devlin] When I think about a timing attack as brought up before, the page knows when you're going to show your UI and where it will be presented. Whether the user is accepting a privacy policy or agreeing to play a game or whatever, the page puts a permission confirmation there instead. If the page can display its own UI in the right place a fraction of a second before the extension does…
 * [oliver] The timing attack you're describing is the user sees one UI and the click is long enough that they have time to see one UI they move their cursor and performs another click?
 * [devlin] The concern is that the page shows another UI before one password is able to do it.
 * [rob] The concern is that after the user interacts with the page, there's no reliable way to ensure that the user is interacting with the extension. For argument, say after 10 seconds you know for sure that subsequent interactions will be with the extension.
 * [devlin] Couldn't you get those same guarantees by knowing you're on top and having an event to know when you're no longer on top?
 * [patrick] Yes but that feels convoluted.
 * [devlin] Point is that if we can find a solution that isn't extension specific.
 * [rob] Such a method exists already: [`document.elementFromPoint`](https://developer.mozilla.org/en-US/docs/Web/API/Document/elementFromPoint), but that has not solved the issue.
 * [_unknown_] And no events to detect changes.
 * [ricky] There is some of this in the showPopover method and associate events.
 * [devlin] If you know someone else is trying to draw on top of you, why wouldn't you just ignore the input?
 * [oliver] You could, but that means you can't trust subsequent interactions with the page.
 * [devlin] Then you use a separate, more interruptive flow like showing the popup. How much of a concern is this in practice? How many legitimate sites have this issue?
 * [rene] Comes back to blanket application of trying to detect popovers, z-index, etc.
 * [christian] We don't collect metrics on this kind of thing.
 * [rene] We are very conservative about telemetry.
 * [ricky] Because of how the web platform tends to evolve –it's very expressive– I can't prove that these issues will be thwarted.
 * [devlin] Trying to understand what attacks this truly thwarts.
 * [christian] Two categories of attacks. Timing attack you previously mentioned where some time before interaction, the user is scrolling through a privacy policy, and right before the user clicks OK, that makes the credential manager's dropdown come down and forces the user to click a different set of credentials than they meant to. There's a lot of timing jank for an attacker to get right. They'd probably have a hidden input field that's already set up and ready to take user input.
 * [christian] To rephrase, a site has an accept privacy policy button, a hidden credit card field, and they've rendered enough privacy policy to cover where they know the credential manager's credit card selector will appear. There's no timing in that pre-set up so that no matter how fast the user's interaction is, the user input will go to the credit card interaction.
 * [devlin] If we had that “am I on top” event system you'd have this knowledge and could react appropriately.
 * [christian] I think universally we're exhausted doing detections and patching.
 * [ricky] Bad look for everyone here.
 * [george] More than just showing on top, having a protected layer where you can't be removed would be useful.
 * [devlin] That wouldn't be provided here?
 * [oliver] You have to put in the same DOM, though, that content could be removed.
 * [george] Might be a separate UI primitive.
 * [rob] A canvas where you can paint and accept input events. Don't need to have HTML rendering and other complicated content.


### User Gestures

11:00 - 11:45
Discuss user gesture handling in extensions, including propagation between background and content scripts.

Topics include proposals such as [issue 898](https://github.com/w3c/webextensions/issues/898) and [issue 684](https://github.com/w3c/webextensions/issues/684) related to scripting and user activation.

 * [simeon] Let's start by clarifying user gesture and propagation to other contexts.
 * [devlin] Typically, when an extension sends a message, we check whether there is an active user gesture, and curry it to the recipient of the message. These days we ensure that this cannot be chained forever. 2 axis grid, 4 quadrants: Web vs. extensions. Generating vs. consuming, extension vs. web
   * Web-generated user gesture, consuming user gesture in web APIs.
   * Extension-generated user gesture (e.g. click on extension UI), extension API call consuming user gesture.
 * [rob] Also like to include User activation vs. user gesture. User gestures are only available synchronously. User activation persists for a short time after.
 * [devlin] Same in extensions when we synthesize a user gesture.
 * [sarven] Could you summarize the threat model here?
 * [devlin] Not necessarily based on a threat model; The web evolved. Until a few years ago the web only had a user gesture, but as async APIs became more common, it became obvious that more was needed. We haven't done that in extensions yet. I believe that we should align in extensions.
 * [timothy] I'd also like to do this.
 * [oliver] I feel like we've spoken about moving to the time based window a few times, but we've never aligned we all want to do that.
 * [devlin] First, does any browser not use a time-based user gesture?
 * [oliver] Chrome uses a time window on the web, so does Firefox, does Safari?
 * [timothy] I'm pretty sure that we do.
 * [devlin] Okay, wanted to confirm that we all currently do this for the web.
 * [patrick] By the way, the spec specifies user activation as time based.
 * [rob] Slight complication is that user activation is bound to the document. For us (extensions) the context is the browser.
 * [devlin] When the user interacts with the browser, we only synthesize the gesture for APIs that would need that. For content scripts, we curry the gesture over to the background.
 * [devlin] Something we don't do but we should is consuming user gestures. I'm generally supportive of just using webby stuff. Can't completely rely on the web model, though, because (...) in extensions, if you interact with the browser action, we synthesize the user gesture (because you haven't interacted with the renderer).
 * [oliver] You mentioned consuming user gestures on the web. It appears that some are consuming and some are not. Are you thinking we'd always consume or distinguish between them?
 * [devlin] Leaning towards any API that requires it consumes it.
 * [rob] Do you know whether extensions rely on currying user gestures?
 * [simeon] Absolutely.
 * [rob] For what use cases?
 * [devlin] Anything where a user interaction in the page requires user activation in the background.
 * [simeon] Concrete use case is requesting permissions from a content script.
 * [oliver] Would be useful to create issues to track these use cases. One would be ‘should we curry user gestures?'
 * [rob] For Firefox I'd like to make currying opt in, if we were to implement it.
 * [devlin] I expect that will break existing extensions and web pages.
 * [rob] Firefox does not support currying presently. And extensions should only opt in if they want to consume the user gesture.
 * [oliver] We should have another issue for user gestures in extensions being time based. There's a third one that slipped my mind at the moment.
 * [patrick] Definition of user activation in the browser.
 * [oliver] I think right now there's no
 * [devlin] Time, currying, consuming.
 * [oliver] I can open all of those.
 * [carlos] https://github.com/w3c/webextensions/issues/898
 * [devlin] The issue here is to add a user gesture property to executeScript. Is the request here to make this independent of whether or not the background currently has a user gesture?
 * [carlos] Yes.
 * [devlin] Definitely don't want to do to that.
 * [timothy] Also opposed from Safari's end.
 * [devlin] Would be open to having a separate dedicated API for that. I could see currying the gesture like we do with content scripts.
 * [timothy] Supportive of option for executeScript and sendMessage to support currying.
 * [devlin] Would you be open to a separate API and permission to synthesize a gesture in a web page?
 * [timothy] Possibly. We don't currently prompt for individual permissions. Could be a use case we entertain. Propagation sounds like it would solve 90+% of use cases.
 * [rob] Why do we want gestures without gestures?
 * [devlin] Agentic use cases. May need to synthesize a user gesture. Right now that's done with the debugger API.
 * [rob] Could be discussed, but want that to be separate, not blocking this.
 * [devlin] Understood and agreed.
 * [sarven] Thinking of scenarios where there's a conflict between actions on a web page vs. extensions. Say click in a page vs click in extensions code. What strategies are there to decide priority, whether one overrides the other, and, related, whether all the browsers do things consistently.
 * [devlin] We fire events in the order they were registered. That's not unique to user gestures, that's just event handling.
 * [sarven] Seems like there's a distinction between these cases.
 * [rob] We have separate implementations for web platform APIs (`addEventListener`) and extensions APIs (`addListener`), etc.
 * [sarven] Is there a sense for what additional authority…
 * [devlin] We execute them in order and whichever runs last wins. Your content script might conflict with the page its running on.
 * [devlin] Sounds like for Carlos' issue we have two issues: 1) new permission and new API to synthesize user gestures in content scripts 2) whether we'd want to support currying through to executeScript.
 * [devlin] Agree that we'd want currying to be an opt in. Also should decide whether we want this to be limited to a single frame.
 * [rob] Only want to do it in a specific document and frame.
 * [timothy] Sounds good to me.
 *
 * [Issue 684](https://github.com/w3c/webextensions/issues/684): Feature request: grant user gestures (activeTab?) for omnibox events
 * [devlin] Currently in Chrome we grant an active tab for that event, we do not grant a user gesture.
 * [rob] In Firefox we do both (activeTab and user gesture).
 * [timothy] We don't currently support the Omnibox API, but I'd be supportive of both.
 * [devlin] Just noticed there's additional discussion
 * &lt;everyone reads for a bit>
 * [rob] Updating to “implemented” in Firefox because https://bugzilla.mozilla.org/show_bug.cgi?id=1542358 was resolved.
 * [devlin] The issue has “chrome: implemented”, is that accurate?
 * [rob] There's a patch linked from the issue that I used as motivation for saying Chrome implemented: https://chromium-review.googlesource.com/c/chromium/src/+/5837605
 * [devlin] We do synthesize a user gesture for Chrome.
 * [timothy] Sounds like we can close it.
 * [carlos] Does this address the issue where if you call sidePanel.setOptions() followed by sidePanel.open() you lose the user gesture and sidePanel.open() fails?
 * [devlin] Doesn't address that.
 * **Resolution**: Close [Issue 684](https://github.com/w3c/webextensions/issues/684). It is implemented in all browsers that support the API.
 * **Action Item**: Oliver to file follow-ups for user gesture related topics. User activation has support from everyone, currying and consumption needs more discussion.
 * [devlin] Someone should file a 4th issue: a new API and new permission to synthesize user
   * Original issue renamed to: [Issue 898](https://github.com/w3c/webextensions/issues/898): Add a way to synthesize user gesture on a page as extension


### Bug Triage

11:45 - 12:30, 13:45 - 14:15
Continue reviewing open GitHub issues and pull requests.

 * [Issue 274](https://github.com/w3c/webextensions/issues/274): reconsider best api design based on comments from i18nwg
   * [carlos] Last year at TPAC 2024 we discussed four proposals. Eemeli seemed to favor this concrete proposal and left [a comment](https://github.com/w3c/webextensions/issues/274#issuecomment-2780632854). Without a live object you'd get really weird behavior.
   * [carlos] The proposal is to have an initial async call that returns a result which can be used to get data synchronously.
   * [simeon] Eemeli's suggestion looks like a nicely shaped, usable API.
   * [devlin] Nothing has changed since we spoke about this last. We don't have live objects in APIs and I still have concerns about that.
   * [rob] There are extension messaging ports. Does not need to be prototype-based, could be object with functions as properties.
   * [devlin] In Chrome it is more difficult technically to return a live object.
   * [carlos] Does Firefox have objections to a live object?
   * [rob] I do not have objections.
   * [carlos] Where is this on the timeline for Chromium?
   * [devlin] This is not a hill I would die on. A live object makes it less likely we would get to this earlier.
   * [carlos] Would you accept a patch using live objects?
   * [devlin] Sure.
   * [oliver] I will leave a comment saying we are happy with the new proposal.
   * [devlin] This is proposal A
   * **Resolution**: Consensus on Proposal A for getLanguageDictionary.
 * [Issue 873](https://github.com/w3c/webextensions/pull/873): Add specification for externally_connectable
   * [kiara] This is the specification for externally_connectable. There were some comments which I have addressed. There was a comment about it being unclear the two ways in which an extension can connect to another extension.
   * [devlin] If you don't specify externally_connectable, any extension can connect to your extension. I wonder how many extensions rely on this behavior.
   * [rob] I'm sure extensions rely on it in Firefox. Tree Style Tabs uses this. Firefox supports `onConnectExternal` but not `externally_connectable`.
   * [timothy] We do support externally_connectable with websites in Safari, but not with other extensions.
   * [rob] Do we want to specify what is exposed on `window.browser`?
   * [devlin] I still agree with the text that we should not specify what APIs are available.
   * [oliver] When we document messaging, should we specify that browser.runtime.sendMessage is how you send a message from a web context?
   * [devlin] Yes.
   * [devlin] There is text in the PR which says `Any [=match patterns=] that include wildcard domains, or wildcard subdomains of a top-level domain, must be ignored.` which is not accurate in Chrome.
   * [oliver] In Chrome if you don't specify externally_connectable it's all extensions, but if you specify externally_connectable and don't specify ids it's no extensions.
   * [oliver] Should we start moving towards defaulting to no extensions can connect when externally_connectable is missing?
   * [devlin] I'd like that.
   * [rob] I [suggested](https://github.com/w3c/webextensions/pull/873#discussion_r2521068008) a clarification that onConnectionExternal and onMessageExternal are not available to webpages, only to (privileged) extension contexts. Looks good?
   * [devlin] Yes.
   * [rob] “extension context” is ambiguous, so I wonder whether we should prepend “privileged”. Is this meaningful to everyone?
   * [oliver] Should we define what privileged extension contexts are in the spec?
   * [devlin] Yes.
   * [oliver] Should we do it in this PR?
   * [everyone] **No.**
   * [kiara] I was planning to add specs for runtime for the three tests we currently have.
   * https://github.com/w3c/webextensions/pull/873/files#r2462681677
   * [rob] Should about:blank, blob: URLs etc. not be able to connect?
   * [devlin] We don't define extension APIs in those contexts.
   * [simeon] What if content scripts have been injected?
   * [devlin] To clarify, we do not define extension APIs in the main world.
   * [rob] I think it is ok if we limit to HTTP and HTTPS. If we wanted to have it match about:blank etc as well, we could refer to [specification/index.bs: "Determine the URL for matching a document"](https://github.com/w3c/webextensions/blob/6d2086f01a4d149bcd1ec024eb40e8b08b3e2072/specification/index.bs#L301-L331) and state that match_origin_as_fallback is implied true.
   * **Action Item**: Rob to specify “privileged extension context”
     * https://github.com/w3c/webextensions/pull/905
 * [Issue 882](https://github.com/w3c/webextensions/pull/882): Proposal: WebRequest.securityInfo API for receiving TLS certificate from web requests.
   * [timothy] We discussed this at the last WECG meeting.
   * [simeon] Since we last discussed this, [PR 899](https://github.com/w3c/webextensions/issues/899)
   * [oliver] There are two approaches we discussed. Firefox has a getSecurityInfo() method you can call. The original Chromium proposal was to have this always exposed if you added an extraOptions. Did we align here?
   * [rob] I am open to the second approach.
   * [rob] One of the ways to do this is to have a method to fetch more information about the request. Are you opposed to this API design for everything, or are there cases would you be open to this in some cases?
   * [devlin] We should not move everything to methods by default. However, there may be some events where we can add methods to get additional data. I am not aware of any that I would be supportive of. I am not supportive of doing it in this case.
   * [simeon] For clarity, last week what was the motivation for the method-based approach?
   * [rob] A method can take options to configure behavior, instead of requiring all potential results to be included in the event details.
 * [Issue 917](https://github.com/w3c/webextensions/issues/917): Read-only Management API
   * [oliver] A use case we were discussing was that an extension could show other extensions that are installed. The best API extensions can use for this at the moment is Management, but that allows other, scarier capabilities like disabling other extensions. We could mitigate this by introducing a new permission that would only allow read-only access to the data exposed by this API.
   * [tomislav] Would this be a permission without a prompt or less scary?
   * [oliver] There would still be a message, a less scary one.
   * [kiara] We don't support Management, so we are neutral.
   * [rob] But you (Safari) does not support permission messages either, so it would not make a difference either way.
   * [george] We have a use case where we have a companion extension.
   * [oliver] Name? “management.read”, “management.readOnly”?
   * [rob] “.readOnly” suffix, and applied generally to other permissions as well. As a convention, I like this pattern.
   * [oliver] downloads.open - would that be part of read only?
   * [devlin] Way out of scope
   * [oliver] I think it's relevant as we're trying to scope out the pattern.
   * [devin] Open is not read only.
   * [rob] downloads API is not a great example; `downloads.download()` is writing something, and core functionality already available without permissions. But completely unrelated to this.
   * [oliver] Ultimately what they want to know is whether there are any extensions installed that use declarativeNetRequest installed.
   * [rob] Does that help? Just having the permission doesn't mean there are any rules.
   * [oliver] Useful as a proxy for having a content filtering extension installed.
 * [Issue 832](https://github.com/w3c/webextensions/issues/832): Spec clarification: TabId 0
   * [simeon] Tophf mentioned that Firefox uses 0. Rob, do you know if/how we use it?
   * [rob] tabId in Firefox is never zero. Internal implementation detail: on desktop it is a counter starting at 1, on mobile it is a non-zero number of at least 10000 (extensions should NOT rely on this value, but we intentionally avoid non-zero - [source](https://searchfox.org/firefox-main/rev/4fd0fa7e5814c0b51f1dd075821988377bc56cc1/mobile/shared/modules/geckoview/GeckoViewTab.sys.mjs#39-41)).
   * [devlin] Don't think we ever use 0, but not sure. Trying to verify.
   * [kiara] Seems there was a time where we may have used 0, but not any more.
   * [carlos] Orion uses 0 for TAB_ID_NONE instead of -1.
   * [rob] We should not use 0, extensions in practice can confuse it with undefined/null in falsey checks.
   * [oliver] Agreed.
   * [devlin] Extension authors should be using -1 to mark invalid tabs, 0 is not special.
   * [carlos] API design is a good opportunity to avoid potential bugs.
   * [devlin] Don't think this reduces common bugs. -1 should be used to mark invalid tabs, developers should not be doing truthy checks.
   * [rob] Beyond tabId -1, a tabId having a value does not mean that it is a valid tab. The tab could have closed for example.
   * [patrick] I did a quick check, and there is a non-neglibile amount of extensions doing truthy check with tabId.
   * [devlin] tabId is from a component external to extensions; I don't think that we can guarantee not returning 0.
   * [rob] I would be okay with leaving it unspecified. We would never return 0 in Firefox though.


### Sidebar API

14:15 - 15:00
Discuss ongoing work toward a unified sidebar/sidePanel API for extensions, including lifecycle events, tab-specific behavior, and cross-browser consistency.
See [issues 128](https://github.com/w3c/webextensions/issues/128), [515](https://github.com/w3c/webextensions/issues/515), [517](https://github.com/w3c/webextensions/issues/517), [521](https://github.com/w3c/webextensions/issues/521), [588](https://github.com/w3c/webextensions/issues/588), [616](https://github.com/w3c/webextensions/issues/616), and [833](https://github.com/w3c/webextensions/issues/833) for background.

 * Issues:
   * [Issue 128](https://github.com/w3c/webextensions/issues/128): Proposal: agree on a unified sidebar API for mv3
   * [Issue 515](https://github.com/w3c/webextensions/issues/515): `sidePanel` API: support "one instance per tab" in `openPanelOnActionClick`
   * [Issue 517](https://github.com/w3c/webextensions/issues/517): `sidePanel` API: lifecycle events
   * [Issue 521](https://github.com/w3c/webextensions/issues/521): `sidePanel` API: `sidePanel.close()` and `sidePanel.toggle()`
   * [Issue 588](https://github.com/w3c/webextensions/issues/588): Tab-specific sidePanel inconsistencies when opening new tabs/switching tabs
   * [Issue 616](https://github.com/w3c/webextensions/issues/616): Content script injection inconsistencies in the sidePanel
   * [Issuu 833](https://github.com/w3c/webextensions/issues/833): Side Panel API: query position: left/right, close(), and focus(): tab to and from side panel
   * [PR 837](https://github.com/w3c/webextensions/pull/837): close() method for the sidePanel API
 * [kiara] Will `sidebar_action` be available on the browser namespace in Chrome?
 * [devlin] No.
 * [oliver] Re [PR 837 (comment)](https://github.com/w3c/webextensions/pull/837#issuecomment-3491968817): In the scenario of only global sidepanel open, no tab-specific panel, hoping to remove fallback to global panel when tabId is not specified from `open()`. Separately, I'd like to see the same behavior between `sidepanel.close` and `sidepanel.open`, but `open` has already shipped. The fact that developers are doing this is an indication of the expected behavior. New proposed behavior: if you call `sidepanel.open()` or `sidepanel.close()`, we should open / close the global sidepanel.
 * [kiara] Do they differ in behavior currently?
 * [devlin] Slight concern about TOCTOU issue and closing the wrong panel.
 * [oliver] Do you have an example of a situation where this is a practical concern?
 * [devlin] Scenario: extension has contextual sidepanel and a global one; contextual panel was closed, but before the extension detected that it calls close, and then closes the global panel inadvertently.
 * [oliver] I thought if we closed the contextual side panel, it went back to the global side panel.
 * [carlos] There's two behaviors an extension developer may want. Always close or fall back. But you can't choose between the two if the API closes the global as fallback. While if you throw an exception when no contextual sidebar is present, a developer can still close the global if requested in the exception handling.
 * [rob] If an extension wants to close a contextual side panel, they pass a `tabId`. The expectation for it is to close the sidepanel.
 * [oliver] That would work as you described, and if the contextual sidepanel is not opened, the global one is closed instead.
 * [rob] As an extension developer, I would expect `close()` to close the sidepanel independently of what exactly is shown.
 * [oliver] Do we think sidepanel.open should match the behavior of close? I would prefer to keep the behavior consistent.
 * [patrick] If this is a breaking change, we can reach out to the affected developers. This group of developers is generally pretty engaged.
 * [oliver] I'm curious about your perspective, Kiara.
 * [kiara] To me, it makes the most sense to not close and throw an error if called with a tab ID. I don't necessarily think we should break things, but if we were doing it from scratch I'd want them to be consistent.
 * [patrick] I wouldn't say I want to make a breaking change, but I think it's doable.
 * [oliver] So are we aligned with falling back in open(), but not in close()?
 * [rob] So if you call open() with options it opens, and pass the same options to close(), it does not close…?
 * [oliver] Yes.
 * [rob] That sounds strange.
 * [devlin] I don't like any of the options on the table right now.
 * [george] How are extensions misusing the current API?
 * [oliver] I think the issue is that not many people are using contextual side panels. They are opening a global side panel by passing a `tabId`.
 * [oliver] If there are no objections, I think we'll move forward with open() remaining as is with fallback behavior. We'll update close() to have no fallback behavior.
 * [kiara] Is this worth a manifest V4 tag to change in the future?
 * [oliver] Yeah, maybe.
 * [rob] Why are these the only options?
 * [oliver] They're not, just the options we're open to considering.
 * [rob] …
 * [oliver] Open exists and has been shipping for a year. Close effectively doesn't exist. We can change that behavior.
 * [rob] There are extensions that only care about global, that only care about contextual, and that care about both. …
 * [oliver] What you are suggesting is what I proposed at the beginning.
 * (...)
 * [rob] The lack of symmetry is not ideal, but there are alternatives if an extension really wants to close (`sidepanel.close()` or `window.close()` DOM).
 * [oliver] In summary, the behavior we aligned on was that open remains as is with fallback behavior. Close is implemented without fallback behavior.
 * [Issue 128](https://github.com/w3c/webextensions/issues/128): Proposal: agree on a unified sidebar API for mv3
   * [rob] I believe we agreed that we should unify on “sidebar” modeled on the intersection of sidepanel.
   * [kiara] What's the action item here?
   * [devlin] I believe we were aligned on adopting the behavior of sidepanel everywhere and having Chrome alias sidepanel to sidebar.
   * [oliver] I can put up a CL that aliases sidebar to sidepanel.
   * [rob] Before doing that, it would be nice if there is an independent implementation to make sure that the proposed behavior is interoperable.
   * [carlos] Good point. Chrome doesn't support closing with arguments but Firefox does.
   * [devlin] In general we don't like falling back to the active window because it's non-deterministic and confusing to developers.
   * [oliver] And what if you have a contextual side panel? Do we close the side panel for the active tab as well?
   * [devlin] We shouldn't try to guess the tab the developer intended.
   * [carlos] Should `sidebar` have consistent behavior across browsers and the non-aliased versions have more specific behavior?
   * [devlin] If we decided on different behavior than current, I think we'd consider that on a case by case basis and make that change in `sidebar`.
   * [oliver] Do you know how heavy a lift that would be to have separate behavior for specific methods and not just alias them?
   * [devlin] Shouldn't be bad.
   * [rob]
   * [carlos] Wouldn't like that. Trying to make all the behaviors work across different APIs isn't easy. Some other browsers use their own namespaces, like Opera using `opr` instead of `chrome`.
   * [rob] What's your desired behavior?
   * [carlos] Do not do aliases.
   * [rob] In Firefox we already have context menus and menus. They are identical, but Firefox has some additional capabilities. Are there many examples where there are inconsistencies of note?
   * [carlos] I think they are too different to just alias.
   * [oliver] I thought sidepanel would be aliased to sidebar_action, but sidebar wouldn't just be an alias to side panel.
   * [rob] Correct.
   * [kiara] sidebar_action and sidepanel are aliases (not shipped).
   * [oliver] I'm hearing that the ask right now is to not alias.
   * [rob] But it might be okay to alias … ?
   * [oliver] Let's revisit.
   * **Action item:** Rob and Oliver to verify feasibility of aliasing sidebar to sidepanel.


### Next meetup in 2026

 * [oliver] Google hosting next meetup (after Apple and Mozilla hosted the previous ones). I'm looking for London as an option.
 * [patrick] Considering late April, any objections?
 * (no objections)

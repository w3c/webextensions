# WECG Meetings 2025, Public Notes, Dec 18

 * Chair: Simeon Vincent
 * Scribes: Rob Wu

Time: 8 AM PST = https://everytimezone.com/?t=69449580,3c0
Call-in details: [WebExtensions CG, 18th December 2025](https://www.w3.org/events/meetings/6a0eda89-558c-408d-b83d-5f03b8853c30/20251218T080000/)
Zoom issues? Ping @zombie (Tomislav Jovanovic) in [chat](https://github.com/w3c/webextensions/blob/main/CONTRIBUTING.md#joining-chat)


## Agenda: [discussion in #925](https://github.com/w3c/webextensions/issues/925), [github issues](https://github.com/w3c/webextensions/issues)

The meeting will start at 3 minutes after the hour.

See [issue 531](https://github.com/w3c/webextensions/issues/531) for an explanation of this agenda format.

 * **Announcements** (2 minutes)
   * Simeon's upcoming affiliation change(s)
 * **Timely issues** (10 minutes)
   * [w3c/charter-drafts#711](https://github.com/w3c/charter-drafts/pull/711/): WEWG charter progress
 * **Triage** (15 minutes)
   * (Closed)[ Issue 927](https://github.com/w3c/webextensions/issues/927): Proposal: Native Isolated Sandbox API for Safe Code Execution
   * [Issue 926](https://github.com/w3c/webextensions/issues/926): Lifecycle event inconsistencies on enable and reload
   * [Issue 353](https://github.com/w3c/webextensions/issues/353): Support onEnabled event when the extension from disabled state to enabled state
     * [Issue 353 (comment)](https://github.com/w3c/webextensions/issues/353#issuecomment-3628341202): Correcting `onExtensionLoaded` event's `reason` parameter
   * [Issue 617](https://github.com/w3c/webextensions/issues/617): manifest key to enable automatic injection of content scripts after installation/update
     * [Issue #617 (comment)](https://github.com/w3c/webextensions/issues/617#issuecomment-3620822767): Content script injections onInstalled, onEnabled and onPermission
     * [Issue #617 (comment)](https://github.com/w3c/webextensions/issues/617#issuecomment-2761249918): Introducing a `content_scripts.can_run_later` property
 * **Check-in on existing issues** (20 minutes)
   * (None)
 * **Open discussion queue (add yourself at the bottom)**
   * [rob] splitview APIs (no issue yet, https://bugzilla.mozilla.org/show_bug.cgi?id=1993037)
   * [kiara] Potential limits on how much data can be retrieved at once from storage.local.get()


## Attendees (sign yourself in)

 1. Rob Wu (Mozilla)
 2. Mukul Purohit (Microsoft)
 3. Oliver Dunk (Google)
 4. Dave Vandyke (DuckDuckGo)
 5. Tomislav Jovanovic (Mozilla)
 6. Simeon Vincent (Mozilla)
 7. Carlos Jeurissen (Jeurissen Apps)
 8. Kiara Rose (Apple)
 9. David Johnson (Apple)


## Meeting notes

Simeon's upcoming affiliation change(s)

 * [simeon] I have been a contracted employee with Mozilla, which is coming to an end by the end of this year. As part of W3 process, expect to have to leave and rejoin the group. Do not expect an impact on the WEWG effort.

[w3c/charter-drafts#711](https://github.com/w3c/charter-drafts/pull/711/): WEWG charter progress

 * [simeon] Outstanding issues/concerns addressed. One comment from Carlos I'd like to touch on. Carlos [suggested](https://github.com/w3c/charter-drafts/pull/711/#discussion_r2449128878) adding “Explicitly mentioning the ability of extensions to alter and add to the browser user interface as not to skip this common oversight (like the way permissions are handled).” as part of discussion at TPAC. Wasn't sure what this was referring to.
 * [carlos] Common pattern with permissions, is that they are currently tied to the current tab. E.g. in Safari, extension badge only appears next to a tab. There are also scenarios where extensions want permissions for a specific host (not tab). The specific fragment is about bookmarks, sidebars, etc., not currently covered by the text.
 * [simeon] I was drawing attention to parts of the UI that the browser chooses to expose but cannot be accessed by extensions (e.g. bookmarks management window).
 * [simeon] I tried to integrate the autonomy section from the WECG in the WEWG. Edited it to flow in the text. Please take a look and review.
   * https://github.com/w3c/webextensions/blob/main/charter.md#autonomy
   * https://github.com/w3c/charter-drafts/pull/711/changes#diff-5edc2c26721b7246f352484d8445394c1f10df1f52a57dd45dced01586689c76R202
   * [Paragraph](https://github.com/w3c/charter-drafts/blob/4847de2e198979b5f51b74c610b073980a8f0469/2025/webextensions-wg.html#L203-L209) starting with “At the same time, we recognize that browser vendors need”

[Issue 927](https://github.com/w3c/webextensions/issues/927): Proposal: Native Isolated Sandbox API for Safe Code Execution

 * [simeon] Although already closed by author shortly after filing, would like to discuss.
 * [simeon] Use case is AI; solution proposed is to execute code in a sandbox, which is a capability generally useful outside of AI. Topic relating to shadow realms.
 * [simeon] Also like to call out that the issue text seems to be AI generated. How should we handle scenarios like this? Issue generated and then abandoned (in this case literally).
 * [rob] Case by case basis. If an idea is sound and a good faith discussion/participation from the author, then the use of AI to write the text is not a problem on its own. However, if they dump a wall of text and do not participate at all, then I'd be more inclined to close the issue.
 * [oliver] I've seen this pattern elsewhere, where an issue is created and seems reasonable but is then quickly close, and don't understand it. In general I agree with Rob that we should handle these on a case by case basis. In some situations we may want to move forward with the suggestion, but I don't think we should have to drive something because an issue was opened.
 * [oliver] I recall a recent case where the PR was AI generated.
   * https://github.com/w3c/webextensions/pull/921
   * https://github.com/w3c/webextensions/pull/922
 * [carlos] These were low quality, Timothy closed as spam.

[Issue 926](https://github.com/w3c/webextensions/issues/926): Lifecycle event inconsistencies on enable and reload

 * [carlos] This group of issues is all related to lifecycle events, including:
   * [Issue 353 (comment)](https://github.com/w3c/webextensions/issues/353#issuecomment-3628341202): Correcting `onExtensionLoaded` event's `reason` parameter
 * [Issue #617 (comment)](https://github.com/w3c/webextensions/issues/617#issuecomment-3620822767): Content script injections onInstalled, onEnabled and onPermission
 * [Issue #617 (comment)](https://github.com/w3c/webextensions/issues/617#issuecomment-2761249918): Introducing a `content_scripts.can_run_later` property
 * [carlos] This one is related to events dispatched when an extension is enabled and disabled. Also looked at reloading. Seems like we should agree on the expected set of behaviors before implementing the new lifecycle events.
 * [simeon] Did you test with temporary extensions or extensions installed through the standard end user flow?
 * [kiara] Safari case, the reload bug you saw is only for temporarily loaded extensions, because we don't have a bundle. If you change the version in the manifest, the reason will change.
 * [dave] (in chat) Another difference like that I noticed was setUninstallUrl causing the page to show in new tab that's focussed in Chrome but not focussed in Firefox, IIRC.
 * [oliver] We fire “update” when you reload an unpacked extension, but don't do that for a packed extension. This is done because this enables testing of a common flow.
 * [carlos] `chrome.runtime.reload()`, would that not trigger any event?
 * [oliver] I don't think so.
 * [carlos] We should test this.
 * [simeon] I believe that in Chrome and Firefox you can emulate the experience by dragging a custom crx / xpi into the extension management page.
 * [carlos] I will test and comment on the issue.
 * [kiara] Firing onEnabled instead of onInstalled would make sense for the scenario of the user enabling an extension. I'll discuss that internally, to see if there are compatibility issues.
 * [oliver] We should figure out which reason takes precedence (install, update, enable, etc.). If onExtensionLoaded were to be implemented, that would be much clearer.
 * [simeon] Would it make sense to specify temporary installation behavior in our spec?
 * [rob] Could call it out as a concept. In practice all browsers here support unpacked/temporary extensions, in a zip file format. Not all browsers support zip files for installation in production, so calling it out could also enable us to relate the spec to wpt.
 * [oliver] Agree with the call-out, 50/50 on whether we'd want to specify onInstalled behavior for unpacked.
 * [simeon] Makes sense. Not sure if it should be specced behavior, a non-normative note, or just in documentation. I think developers may want predictability. The current behavior evolved because it was useful for development, but I would expect devs will file bugs if dev flow doesn't follow the spec.
 * [dave] As a developer it is not always clear which APIs are only available to unpacked extensions.
 * [rob] At least in Chrome and Firefox, temporary/unpacked extensions have access to some additional declarativeNetRequest APIs, also an option to accept localhost as script-src in CSP.
 * [simeon] I think I'm coming around to having development time behavior be called out in a non-normative note. Dave's suggestion of having a control to opt into “packed” behavior makes sense and seems like a browser choice.
 * (discussion on the other three issues continues below)

[Issue 353](https://github.com/w3c/webextensions/issues/353): Support onEnabled event when the extension from disabled state to enabled state

 * [Issue #353 (comment)](https://github.com/w3c/webextensions/issues/353#issuecomment-3628341202): Correcting `onExtensionLoaded` event's `reason` parameter
 * [carlos] Seems the current proposal mentions reasons `installed` and `updated`. While the current onInstalled reasons use `install` and `update`. Considering no browser has yet implemented these events. I suggest we update the proposal to match the current onInstalled reasons as mentioned here:
   * https://developer.chrome.com/docs/extensions/reference/api/runtime#type-OnInstalledReason
   * https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/OnInstalledReason
 * [kiara] Matching makes the most sense to me.
 * [oliver] I don't recall the reason for the differences, but matching makes sense to me.
 * [carlos] I'll change the PR to let the reasons match.

[Issue 617](https://github.com/w3c/webextensions/issues/617): manifest key to enable automatic injection of content scripts after installation/update

 * [Issue #617 (comment)](https://github.com/w3c/webextensions/issues/617#issuecomment-3620822767): Content script injections onInstalled, onEnabled and onPermission
 * [carlos] Different browsers inject content scripts on some events, but not others. This behavior is not consistent across browsers. I think it would make sense to align on common behavior, or possibly introduce a property on the content script to specify the behavior being requested by the extension.
 * [carlos] E.g. as suggested in [Issue #617 (comment)](https://github.com/w3c/webextensions/issues/617#issuecomment-2761249918), could introduce a `content_scripts.can_run_later` property to opt in to Firefox/Safari behavior.
 * [oliver] With the new extensions menu we're testing, we have a behavior where if you add a new extension that wasn't there before, we inject content scripts. Was the idea of the proposal that extensions could define how they want their content scripts to be injected on install?
 * [carlos] Yes. Not sure if this creates issues.
 * [oliver] It creates new cases where the browser would inject content scripts in response to a permission being granted. In the abstract we're supportive. Want to see an actual proposal.
[rob] splitview APIs (no issue yet, https://bugzilla.mozilla.org/show_bug.cgi?id=1993037)

 * [rob] Firefox is working on split view functionality. I took a look at the current APIs and I think we need a bit more API surface to support this well, beyond what was specified before in https://github.com/w3c/webextensions/pull/842.
 * [oliver] This feature has shipped in Chrome. I believe everything we've discussed in this group has been implemented and shipped. Open to further discussion on expansion of the APIs.
 * [rob] One of the things that makes an API definition a bit difficult is that the concept of a split view, what it is, could be, should be, is not well defined. Does Chrome have a reference doc here?
 * [oliver] Don't know if there's anything beyond existing blog posts.
   * [oliver] News article: https://www.androidauthority.com/chrome-split-view-feature-3613155/
 * [rob] For example, a split view currently consists of two adjacent tabs. Not clear if adjacency is required or if there could be different arrangements. This does affect API design.

[kiara] Potential limits on how much data can be retrieved at once from storage.local.get()

 * [kiara] Recently had a bug where we had a crash if you tried to serialize too much data at once. Also tested in Firefox and Chrome; Chrome observed a similar crash. Figured it might be good to discuss here how we approach implementing this.
 * [oliver] We'll definitely look into this.
 * [mukul] This only happens when `unlimitedStorage` is granted?
 * [rob] Yes, but this is a broader issue. Happens with `unlimitedStorage` because it allows the amount of data to significantly increase. The core issue is related to exceeding IPC limits.
 * [rob] I'm curious about reasonable limits that could still be useful to developers. What concrete steps can we follow up on?
 * [kiara] This crash wasn't related to IPC, rather buffer overflow. But we can do an audit of the existing APIs for their ability to exceed IPC or buffer limits. Could try to bucket IPC, buffer sizes.
 * [oliver] Chromium bug: https://issues.chromium.org/427600178. Our short term solution was to add a limit of 25Mb for `get()` calls.
 * [kiara] Did that ship?
 * [rob] Yes, in 142. https://chromiumdash.appspot.com/commit/3695e1d20d45e1e0d566b650bd510f381167f5f2
 * [simeon] Reminds me of an old Chrome issue where image decoding of very large images in themes (>4k) failed.
 * [dave] (in chat) I wonder if there should be something in the API for developers to check the limit too?
 * [rob] In Firefox storage.local is backed by IndexedDB, so the implementation benefits from the expertise of those working on that for the web platform. Do you know what Chrome's limits are for IndexedDB?
 * [oliver] I don't know what our IndexeDB limits are.

The next meeting will be on [Thursday, January 15th, 8 AM PST (4 PM UTC)](https://everytimezone.com/?t=69697f80,3c0). We are skipping the meeting on January 1st, 2026.
